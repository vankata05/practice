/*
Една малка фирма - SGD, която иска да пробие в сферата на Game development се заела да разработи билярд игра. По време на разработката, членовете на SGD се разделили в два екипа - Frontend и Backend. Първият екип имал за цел да изгради полето, да анимира движението на топчето - като цяло всичко, което потребителя вижда. Докато вторият екип имал за целта да изчисли до какви промени води удара на топчето - където е неговото ново местоположение, ще се удари ли някъде  - като цяло всички сметки, които потребителя не вижда и не разбира .
Първия екип започнал успешно работата си, но втория екип имал голям проблем. Никога не са занимавали с математика и нямали представа как трябвало да изчислят всичко това. И тук идва вашата задача. Трябва да помогнете на Backend екипа да изчисли движението на топчето.
За целта трябва да реализирате програма, която изчислява чрез силата на удара и посоката на вектора следващата позиция на топчето.
	Това, което трябва да знаете за масата за билярда е, че страните ѝ винаги трябва да са в отношение 1:2. По подразбиране са зададени диаметър на топчето, стартовата точка на топчето и ъгловите точки на полето, които НЕ е задължително да образуват прави, които са успоредни на координатните оси. Всичките тези характеристики на масата могат да бъдат променяни с конкретни команди.
Примерна постановка:



	Изисквания към задачата:
Силата на удара трябва да е число с плаваща запетая в диапазон [1,10]. Силата на удара представлява “големината” на вектора.
Посоката се определя от подадена точка. Както виждаме в примера горе, нашата посока се определя от точката с координати (230,50). При сила = 1, топчето се премества така, че центъра му да отиде в подадената точка (точката (230, 50) в нашия пример). При сила > 1, центъра на топчето ще продължи след тази точка.
След удар координатите на топчето се променят, но стартовата му точка остава същата.
Полето да бъде описано от точки, образуващи правоъгълник със страни в отношение 1:2
Пример1: Поле с координати (0,0), (320,0), (320,160), (0,160) ; 
Пример2: Поле с координати (20, 10), (120, 110), (70, 160) и (-30, 60); 
При въвеждане на полето покоординатно се счита, че те винаги са в реда долу вляво, долу вдясно, горе вдясно, горе вляво (т.е. не трябва да проверявате дали са правилно подредени и/или да ги подреждате сами)
Изискват се два варианта за въвеждане на полето за масата за билярд - simple и complex. Simple варианта приема начална точка и размер на стените; при него предполагаме, че страните на масата са успоредни на координатната система. Complex варианта приема 4 точки по гореспоменатият начин. И за двата варианта е необходима проверка за спазване на отношението 1:2.
При началното подаване трябва да се проверява дали въведеното от потребителя топче принадлежи на диапазона на полето 
При удар в стена, топчето се отблъсква. Логиката за отблъскване е подобна на задача две от първото ви домашно по теория - ако си представяме, че вектора на движение на точка (топче) лежи на една права, то точката (топчето), след “отскок” от стена ще се намира върху отразената на тази права, на място симетрично на това, което е щяла да стигне ако стената я нямаше.
При удар в ъгъл, т.е. когато едновременно достигне две стени, топчето се връща в началната си позиция. Това е аналог на падането в дупка при билярда. Дупки по средата на дългите странни тук няма.
Програмата трябва да работи като меню (подобно на домашното), което представлява безкраен цикъл. Какви точно команди ще използва то преценявате вие, като трябва да има команди за: инициализация на данните на полето (размери, точки на ъгли, стартова точка на топчето, диаметър на топчето), смяна на всяка от данните на полето, изкарване на данните на полето на екрана (подобно на това което прави “f” в примера по-долу),  удар на топчето, списък от команди и изход от програмата. Опцията за смяна на стартовата точка на топчето трябва да поддържа не само директно въвеждане от стандартния вход, но и запазване на сегашната позиция на топчето като нова стартова позиция. Можете да добавяте и други команди, като в списъка от команди се очаква да обясните какво правят те.
Примерни вход и изход за удар:
Примерите по-долу използват примерни команди в менюто - не е задължително при вас да са същите.

* Полето има координати (0,0); (320, 0); (320, 160); (0, 160) 
В нашия код това се подава например като:
0 0
320 160
(т.е. поле с начална точка 0 0 и страни равни на 320 и 160 (при този случай страните на полето са успоредни на координатната система - simple case)
или като:
	0 0
320 0
320 160
0 160
Пример 1: в случай, че топчето ни е в позиция (280,70) и с диаметър 0
280 70
0
Удар:
h
230 110
2
Тук е използвана командата h за да се усъществи  удар към точка (230, 110) със сила 2
Изход:
	f
Field points:
 	(0, 0)
  	(320, 0)
  	(320, 160)
  	(0, 160)
	Ball center - (180, 150)
Ball diameter - 0
За изкарване на информация за полето използваме командата f, в случая виждаме, че след удара топчето има нова позиция - (180, 150)

Пример 2: в случай, че топчето ни е в позиция (300,60)
300 60
0
Удар:
h
250 30
3
Изход:
	-- The ball bounced into the wall at (200, 0) - това е само за примера, не е нужно да го изкарвате
f
Field points:
 	(0, 0)
  	(320, 0)
  	(320, 160)
  	(0, 160)
	Ball center - (150, 30)
Ball diameter - 0
Заб: В примера диаметъра на топчето е 0. Ако топчето има диаметър 10
(радиус 5), ще се удари в стената при координати (208.3333333,5) и ще приключи в (150,40), т.е.:
300 60
10
h
250 30
3
f
Field points:
 	(0, 0)
  	(320, 0)
  	(320, 160)
  	(0, 160)
	Ball center - (150, 40)
Ball diameter - 10
Пример 3: в случай, че топчето ни е в позиция (230,50)
230 50
0
Удар:
h
200 20
2  
Изход:
	-- The ball bounced into the wall at (180, 0)
f
Field points:
 	(0, 0)
  	(320, 0)
  	(320, 160)
  	(0, 160)
	Ball center - (170, 10)
Ball diameter - 0
Заб: В примера диаметъра на топчето е 0. Ако топчето има диаметър 10 (радиус 5), ще се удари в стената при координати (185,5) и ще приключи в (170,20 ).
230 50
10
h
200 20
2
f
Field points:
 	(0, 0)
  	(320, 0)
  	(320, 160)
  	(0, 160)
	Ball center - (170, 20)
Ball diameter - 10

** Полето има координати (20, 10); (120, 110); (70, 160) и (-30, 60):
В нашия код това се подава например като:
20 10
120 110
70 160
-30 60

Т.е. поле с ъгли в точки  (20, 10); (120, 110); (70, 160) и (-30, 60) (при този случай страните на полето не са успоредни на координатната система - complex case).
Пример 4: в случай, че топчето ни е в позиция (60,80)
	60 80
0
Удар:
h
50 50
2 
Изход:
	-- The ball bounced into the wall at (45, 35)
f
Field points:
 	(20, 10)
  	(120, 110)
  	(70, 160)
  	(-30, 60)
	Ball center - (30, 30)
Ball diameter - 0
Заб: В примера диаметъра на топчето е 0. Ако топчето има диаметър 14.14213562373095 (102), ще се удари в стената при координати (50,50) и трябва да се изчислят новите изходни координати.

*** Полето има координати (60, -80); (220, 40); (160, 120) и (0, 0):
В нашия код това се подава например като:
60 -80
220 40
160 120
0 0
Пример 5: в случай, че топчето ни е в позиция (90,-10)
	90 -10
20
Удар:
h
12 -316
1 
Изход:
	--
f
Field points:
(60, -80)
(220, 40)
(160, 120)
(0, 0)
Ball center - (192, 44)
Ball diameter - 20
При този случай топчето отскача от стените пет пъти. (даденият център е смятан на ръка, така че е възможно да не е с точно тези координати, но със сигурност близки до тях)
Пример 6: в случай, че топчето ни е в позиция (90,-10)
	90 -10
20
Удар:
h
65 -45
1
h
40 -220
1
Изход:
	--
f
Field points:
(60, -80)
(220, 40)
(160, 120)
(0, 0)
Ball center - (90, -10)
Ball diameter - 20
В този пример удряме топчето два пъти, като на втори път то влиза в дупката и се връща в най-първата си позиция.






Оценяване(2-6):
	0-0.25:  Преместване на топче по дадена посока (т.е. при сила = 1)
	0-0.25:  Движение на дадено топче по дадена посока и сила (> 1)
	0-0.5: Ограничаване на параметрите спрямо посочените по-горе изисквания. Изкарвайте съответно съобщение, ако ударът е невалиден.
	0-1: Отблъскване на топчето в стена/ъгъл на полето - тук въвеждаме полето като фактор, т.е. до сега приемаме, че не е съществувало
	0-0.75: Отблъскване на топчето в стена/ъгъл на полето, където страните на полето не са успоредни на осите на координатната система
	0-0.75: Повече от едно отблъскване
	0-0.5: Качествен код - важи над 4

Бележка: 2.99 е 2

Важно: 
Менюто е безкраен цикъл. 
Кода трябва да е реализиран на C++ и да спазва правилата за качествен код на езика и на ООП.
Слагайте коментари! Не само водят до по-качествен и по-четим код, но и помагат при оценяването (могат да донесат бонус точки)
Може да използвате даван от нас код в рамките на час/домашна работа.
Задачата е опростена максимално, т.е. не зависи от тежест на топчето, сила на триене и други външни фактори. Но диаметъра на топчето е фактор!
В задачата съществува само едно топче, т.е. е невъзможно да се блъсне в друго топче.

Въпроси: За въпроси, моля добавяйте коментари към заданието или в час/консултация.
*/
//write the program here
#include <iostream>
#include <cmath>
//include library for sleep
#include <unistd.h>

using namespace std;

//class for the ball
class Ball
{
private:
    double x, y, diameter;
    double speedX, speedY;
public:
    Ball(double x, double y, double diameter, double speedX, double speedY)
    {
        this->x = x;
        this->y = y;
        this->diameter = diameter;
        this->speedX = speedX;
        this->speedY = speedY;
    }
    double getX()
    {
        return x;
    }
    double getY()
    {
        return y;
    }
    double getDiameter()
    {
        return diameter;
    }
    double getSpeedX()
    {
        return speedX;
    }
    double getSpeedY()
    {
        return speedY;
    }
    void setX(double x)
    {
        this->x = x;
    }
    void setY(double y)
    {
        this->y = y;
    }
    void setSpeedX(double speedX)
    {
        this->speedX = speedX;
    }
    void setSpeedY(double speedY)
    {
        this->speedY = speedY;
    }
};

//class for the field
class Field
{
private:
    double width, height;
public:
    Field(double width, double height)
    {
        this->width = width;
        this->height = height;
    }
    double getWidth()
    {
        return width;
    }
    double getHeight()
    {
        return height;
    }
};

//function for the collision with the wall
void collisionWithWall(Ball& ball, Field& field)
{
    double x = ball.getX();
    double y = ball.getY();
    double diameter = ball.getDiameter();
    double speedX = ball.getSpeedX();
    double speedY = ball.getSpeedY();
    double width = field.getWidth();
    double height = field.getHeight();

    if (x + diameter / 2 >= width)
    {
        ball.setSpeedX(-speedX);
    }
    else if (x - diameter / 2 <= 0)
    {
        ball.setSpeedX(-speedX);
    }
    else if (y + diameter / 2 >= height)
    {
        ball.setSpeedY(-speedY);
    }
    else if (y - diameter / 2 <= 0)
    {
        ball.setSpeedY(-speedY);
    }
}

//dosplay the ball and field
void display(Ball& ball, Field& field)
{
    double x = ball.getX();
    double y = ball.getY();
    double diameter = ball.getDiameter();
    double speedX = ball.getSpeedX();
    double speedY = ball.getSpeedY();
    double width = field.getWidth();
    double height = field.getHeight();

    //clear the screen
    system("clear");

    //print field and the ball inside of the field
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (i == 0 || i == height - 1)
            {
                cout << "-";
            }
            else if (j == 0 || j == width - 1)
            {
                cout << "|";
            }
            else if (i == y && j == x)
            {
                cout << "O";
            }
            else
            {
                cout << " ";
            }
        }
        cout << endl;
    }

}



//start game
void startGame()
{
    //create the field
    Field field(20, 10);

    //create the ball
    Ball ball(5, 5, 2, 1, 1);

    //display the ball and field
    display(ball, field);

    //move the ball
    while (true)
    {
        //move the ball
        ball.setX(ball.getX() + ball.getSpeedX());
        ball.setY(ball.getY() + ball.getSpeedY());

        //check for collision with the wl
        collisionWithWall(ball, field);

        //display the ball and field
        system("clear");
        printf("\n");
        display(ball, field);
        //sleep for 0.1 seconds
        usleep(20000);
    }
}

//main
int main()
{
    startGame();
    return 0;
}